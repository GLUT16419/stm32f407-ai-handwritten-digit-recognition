# 上位机与单片机联合实现手写数字识别的完整流程分析

这篇文章基于**STM32单片机+STM32CubeAI+上位机**搭建了手写数字识别系统，核心是“上位机负责交互与数据预处理，单片机负责AI推理与识别，串口实现两者数据互通”，整体形成一个闭环工作流程，具体实现步骤如下：

## 一、整体系统架构与分工

整个识别系统分为两大核心部分，各司其职又通过串口通信形成联动，避免了单片机资源不足（无友好交互界面、图像处理能力弱）和上位机实时性不足的问题：

1. **上位机**：负责**手写输入、数据预处理、数据封装发送、识别结果展示**（无AI推理功能，仅做交互与数据中转）。

2. **STM32单片机**：负责**串口数据接收、数据格式转换、CubeAI神经网络推理、识别结果回传**（核心是离线AI识别，不依赖上位机和外部网络）。

3. 通信桥梁：**USART串口（115200波特率、8N1格式）**，实现上下位机的双向数据传输。

## 二、步骤1：上位机端——手写输入与数据预处理、发送

上位机（推测为C#/Python等语言开发，带可视化界面）的核心工作是为用户提供手写入口，并将手写数据转换成单片机可识别的格式，具体操作如下：

1. **提供手写交互界面**：搭建一个28×28像素的手写区域（与MNIST手写数字数据集格式一致），用户通过鼠标/触屏在该区域书写数字。

2. **图像数据预处理**：

    - 将手写区域的图像进行二值化处理（黑白区分，去除杂色），提取每个像素的灰度值（0-255，0为黑色、255为白色）。

    - 将28×28的图像数据转换成一维字节数组（共784个字节，对应单片机端的`28*28`输入要求），每个字节存储一个像素的灰度值。

3. **数据帧封装**：按照约定的格式封装数据，确保单片机能正确识别完整一帧数据（对应单片机端`ONE_FRAME_LEN`的定义）：

    - 帧结构：`1字节帧头 + 784字节像素数据 + 2字节帧尾（含\n换行符）`。

    - 帧尾换行符`\n`是关键：作为单片机判断“一帧数据接收完成”的标志，避免数据丢失或拆分。

4. **串口发送数据**：上位机配置与单片机一致的串口参数（115200波特率、8位数据位、1位停止位、无校验、无硬件流控），将封装好的完整数据帧通过串口发送给STM32单片机。

## 三、步骤2：上下位机通信链路——串口双向数据传输（核心桥梁）

串口是两者唯一的数据交互通道，采用“**单片机中断接收（上位机→单片机）、单片机阻塞发送（单片机→上位机）**”的模式，确保数据传输的稳定性和实时性：

1. **通信参数统一（关键前提）**：上下位机必须严格一致配置如下参数，否则会出现乱码、数据丢失：

    - 波特率：115200

    - 数据位：8位

    - 停止位：1位

    - 校验位：无

    - 流控：无硬件流控

2. **上位机→单片机：中断接收模式**

    - 单片机初始化时开启「单次串口中断接收」（`HAL_UART_Receive_IT`），仅接收1字节数据。

    - 每接收1字节，触发回调函数`HAL_UART_RxCpltCallback`，将字节存入接收缓冲区`uart_rx_buffer`，并更新接收长度计数。

    - 回调函数中自动重新开启下一次中断接收，形成“循环中断接收”，实现连续字节的接收。

    - 当检测到帧尾`\n`时，置位标志位`goRunning=1`，通知主循环“一帧完整数据已接收，可进行后续处理”。

    - 缓冲区防溢出：当接收长度超过`UART_BUFF_LEN`时，重置计数，避免数据覆盖。

3. **单片机→上位机：阻塞发送模式**

    - 单片机封装了`Uart_send`函数，底层调用`HAL_UART_Transmit`，将识别结果以字符串格式发送。

    - 采用超时时间`0xFFFF`的阻塞发送，确保数据完整发送至上位机，无丢失（适合短数据传输，如识别结果）。

## 四、步骤3：单片机端——数据处理与CubeAI神经网络推理（核心识别环节）

单片机接收上位机数据后，完成从“原始数据”到“识别结果”的转换，这是整个系统的核心，具体分为4个子步骤：

### 子步骤3.1：接收完成校验与缓冲区重置准备

1. 主循环持续检测标志位`goRunning`，当`goRunning=1`时，说明一帧数据已接收完成。

2. 首先验证数据长度：判断`uart_rx_length`是否等于`ONE_FRAME_LEN`（787字节），确保数据无丢失、无冗余，避免无效推理。

3. 若长度验证通过，提取有效数据（跳过帧头，取中间784字节像素数据）；若验证失败，直接重置接收状态。

### 子步骤3.2：数据格式转换（适配CubeAI模型输入）

1. 上位机发送的是**8位无符号字节数据（uint8_t，0-255）**，而STM32CubeAI生成的神经网络模型要求**32位浮点数（float）**作为输入。

2. 调用`PictureCharArrayToFloat`函数完成格式转换：遍历784字节的原始数据，将每个`uint8_t`类型的像素值直接赋值给`float`类型的AI模型输入数组`aiInData`（若需更高精度，可在此处添加数据归一化处理，如`dstBuf[i] = srcBuf[i] / 255.0f`，将数据映射到0-1区间）。

3. 转换完成后，`aiInData`数组即可作为AI推理的输入数据，解决了“上位机发送格式”与“单片机模型输入格式”不匹配的问题。

### 子步骤3.3：STM32CubeAI神经网络离线推理（核心识别动作）

这是单片机实现识别的核心，依赖STM32CubeAI工具的前期模型转换和后期代码调用：

1. **前期准备（离线模型转换）**：

    - 提前训练好手写数字识别模型（基于MNIST数据集，通常是CNN或简单全连接神经网络，格式为TensorFlow/PyTorch等）。

    - 使用STM32CubeAI工具，将训练好的模型转换成STM32单片机可运行的C语言代码（自动生成`AI_Init()`、`AI_Run()`等核心函数，优化模型结构以适配单片机的Flash和RAM资源）。

2. **单片机端推理执行**：

    - 系统初始化时调用`AI_Init()`，完成神经网络模型的初始化（加载模型参数、初始化推理环境）。

    - 数据格式转换完成后，调用`AI_Run(aiInData, aiOutData)`，传入转换后的输入数组`aiInData`，获取推理输出数组`aiOutData`。

    - `aiOutData`数组存储了0-9每个数字的识别概率（共10个浮点数，值越大表示该数字的匹配度越高）。

3. **提取最终识别结果**：遍历`aiOutData`数组，找到最大值`max`对应的数组下标`count`，该下标即为最终识别的手写数字（例如，下标5对应的概率最大，则识别结果为5）。

### 子步骤3.4：识别结果回传至上位机

1. 单片机通过`sprintf`函数格式化识别结果：将0-9每个数字的概率、最终识别数字拼接成字符串（存储在`logStr`缓存中）。

2. 调用`Uart_send()`函数，将格式化后的字符串通过串口阻塞发送至上位机。

3. 发送完成后，重置接收状态（清空缓冲区`uart_rx_buffer`、重置`goRunning=0`、重置接收长度`uart_rx_length=0`），准备接收上位机下一次发送的手写数据。

## 五、步骤4：上位机端——接收并展示识别结果

上位机通过串口接收单片机回传的字符串数据，进行解析后，在可视化界面上展示：

1. 解析串口接收的数据，提取每个数字的概率值和最终识别结果。

2. 以友好的形式展示（例如，列表显示0-9的概率、高亮显示最终识别数字）。

3. 清空手写区域（或保留供用户对比），等待用户下一次手写输入，形成循环识别流程。

## 六、整体流程闭环总结

```Plain Text

用户在上位机手写数字 → 上位机预处理并封装数据帧 → 串口发送至单片机 → 单片机中断接收并校验数据 → 数据格式转换适配AI模型 → CubeAI神经网络推理 → 提取识别结果 → 串口回传至上位机 → 上位机展示结果 → 等待下一次手写输入
```

## 关键注意事项

1. 上下位机**串口参数必须完全一致**，否则会出现数据乱码、接收失败。

2. 数据帧格式（帧头、数据长度、帧尾）必须严格约定，确保单片机能正确识别完整数据。

3. 单片机的Flash和RAM资源需满足CubeAI模型的运行要求，避免资源溢出。

4. 串口接收采用中断模式，避免阻塞主循环，保证AI推理和其他任务的实时性。
